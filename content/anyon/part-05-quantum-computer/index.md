# 量子コンピュータとエニオン

Kitaev模型、Kitaev double modelなどをまとめる予定。

この章の記述には以下の文献を参考にした。\

- 渡邊, 入門講義量子コンピュータ, 講談社, 2021

.5ex plus .2ex minus .2ex量子コンピュータの基本事項
量子コンピュータは以下に分類できる。

- 量子ゲート方式

- アニーリング方式

Hilbert空間の次元数に応じた状態の数で同時に計算できるのが量子コンピュータの強みである。

qbit[^45]の候補には以下のようなものがある。

- エネルギーレベル

- スピン

- 光子の偏光

- 電流の向き(超伝導状態の磁束量子など)

- 電荷や光子の有無

- トポロジカル量子

量子ゲート式の量子コンピュータにおけるqbitの条件は以下の通りである(David
P. DiVincenzo)。

1.  scalability

2.  初期化可能

3.  長いコヒーレンス時間

4.  基本ゲートが実現可能

5.  測定可能

6.  静止しているqbitを飛行qbitに変換可能

7.  qbitを確実に輸送できること

.5ex plus .2ex minus .2ex量子アルゴリズム

.5ex plus .2ex minus .2exGroverのアルゴリズム
$N$個のデータから1つを探す問題(探索問題)を考える。
探索問題で最速のアルゴリズムがGroverのアルゴリズムである。

まず、Oracleを定義する[^46]。

::: itembox
**Def.Oracle関数** $x_0$を目的のデータとする。 $$\begin{align}
  f(x) =
\begin{cases}
1 \quad \text{if } x = x_0 \\
0 \quad \text{if } x \neq x_0 \\
\end{cases}
\end{align}$$
:::

$n (2^n > N)$個のqbitを用意する。
これをすべて横向きにした状態を$\psi$とすると $$\begin{align}
\ket{\psi} = \frac{1}{\sqrt{2^n}} ( \ket{0} + \ket{1} + \cdots + \ket{2^n - 1} )
\end{align}$$ となる。

Groverのアルゴリズムは以下の手順で行う。\

::: itembox
**Method. Groverのアルゴリズム**

1.  $2^n \geq N$なる$n$個のqbitを用意して、すべてを$\ket{0}$に初期化する。

2.  Hadamard変換($\pi/2$回転)を全qbitに作用させて、$\ket{\psi}$を作る。

3.  Oracleを作用させて目的のデータを見つけ、その状態の符号を反転させる。

4.  すべての状態の確率振幅の平均を計算し、各状態の確率振幅を平均からの距離だけ反転させる。

5.  3,4を$\frac{\pi}{4}\sqrt{N}$回繰り返す。

最終的に、目的のデータの確率振幅がほぼ1になる。\
:::

.5ex plus .2ex minus .2exShorのアルゴリズム
Shorのアルゴリズムは、素因数分解を多項式時間で行うアルゴリズムである。
量子ゲート式QCができると、ShorのアルゴリズムでRSA暗号が破られる。

まずRSA暗号を説明する。\

::: itembox
**Method.RSA暗号**

1.  素数$p,q(>10^{300})$を選び、$N=pq$を計算する。

2.  $(p-1)(q-1)$と互いに素な整数$d$を選ぶ。$d$を秘密鍵という。
    $$\begin{align}
        \text{gcd}(d,(p-1)(q-1)) = 1
    \end{align}$$

3.  $e$を$ed \equiv 1 \mod (p-1)(q-1)$を満たすように選ぶ。modの上で逆元をとるという操作である。$e$を公開鍵という。

4.  平文をいくつかのブロックに分け、各ブロックを数値$m_j \,,(j=1,2,\ldots)$に変換し、暗号化(encoding)する。
    $$\begin{align}
        m_j \to m_{j'} \equiv m_j^e \mod N
    \end{align}$$

5.  秘密鍵$d$を用いて復号化(decoding)する[^47]。 $$\begin{align}
        m_{j'}^d \equiv m_j \mod N
    \end{align}$$
:::

次にShorのアルゴリズムを説明する。

::: itembox
**Method. Shorのアルゴリズム**

1.  $N$と互いに素な整数$x(1<x<N, \gcd(x,N)=1)$を選ぶ。もし、$\gcd(x,N) > 1$($x$と$N$が互いに素でない)ならば、$\gcd(x,N)$が素因数であるため、それを出力して終わる。

2.  次を満たす最小の整数$r$を見つける[^48]。: $$\begin{align}
        x^r \equiv 1 \mod N
    \end{align}$$

3.  もし$r$が奇数ならば、1に戻る。

4.  もし$r$が偶数ならば、 $$\begin{align}
      x^r -1 = (x^{r/2} -1)(x^{r/2} +1) \equiv 0 \mod N
    \end{align}$$ だから、素因数の候補としてこのふたつができる。

5.  これらが因数でなかった場合、1に戻る。
:::

2がShorのアルゴリズムの本質である。

Shorのアルゴリズムが量子超越性を持つのは、周期性を利用するためである。
つまり。離散フーリエ変換を用いることで、周期$r$を効率的に求めることができる。\

::: itembox
**Method. 離散フーリエ変換を用いた位数の求め方**

1.  $L \geq \log_2 N,\, n \equiv 2L+1$なる$n$qbitの第1レジスタ、$L$qbitの第2レジスタを用意する[^49]。

2.  第1レジスタを初期化したあと、Hadamard変換を作用させる。このときの状態は$\ket{\psi}$である。

3.  第1レジスタの各状態を$j=0 \cdots n-1$とする。これに対応する第2レジスタに$\ket{x^j (\text{mod}N)}$を入れる。

4.  第2レジスタを測定する。第1レジスタには対応する特定の状態のみが生き残る。

5.  第1レジスタに離散フーリエ変換を作用させる。このとき、$2^n/r$の整数倍の状態の係数の絶対値のみが大きくなる。

6.  第1レジスタを測定して位数$r$を求める[^50]。
:::

次は量子コンピュータと暗号の章から

## Sections

